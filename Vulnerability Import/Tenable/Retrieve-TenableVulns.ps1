<#
.SYNOPSIS
  End‑to‑end Tenable.io export via Export API, merge chunks, then convert to a
  one‑CVE‑per‑row CSV. Guarantees a CVE value on every row (uses a placeholder
  when none exists in the source), suitable for downstream imports (e.g., Ninja).

.NOTES
  - PowerShell 5.1+ (faster on PowerShell 7+)
  - Outputs:
      • combined.ndjson  (raw merged export)
      • vulns_cve_exploded.csv  (single CVE per row)
  - Features: region auto‑detection (.com/.eu/.gov), optional X‑Organization header
    for MSSP tenants, chunked download, polling + retries with backoff.
#>

Set-StrictMode -Version Latest
$ErrorActionPreference = 'Stop'
try { [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12 } catch {}

# ============================ CONFIG ============================
$DaysBack = 365   # Export window for "current" vulns

$Config = [ordered]@{
  # ---- Tenable connection ----
  BaseUrl        = 'https://cloud.tenable.com'
  AccessKey         = Ninja-Property-Get tenableClient
  SecretKey         = Ninja-Property-Get tenableSecret
  OrganizationId = $null

  # ---- Export behavior ----
  OutFolder        = 'C:\TenableExport'
  ChunkPollSeconds = 5
  MaxPollMinutes   = 30
  ExportBody       = @{
    filters = @{
      state = @('OPEN')
      since = [DateTimeOffset]::UtcNow.AddDays(-$DaysBack).ToUnixTimeSeconds()
      # Alternative filter example:
      # last_found = @{ gte = [DateTimeOffset]::UtcNow.AddDays(-$DaysBack).ToUnixTimeSeconds() }
    }
    num_assets = 5000
  }

  # ---- CSV output selection ----
  RequireCve   = $true
  NoCveFormat  = 'NOCVE-PLUGIN-{0}'  # becomes e.g. NOCVE-PLUGIN-7287
  Columns      = @(
    'asset.uuid','asset.hostname',
    'plugin.id','plugin.name','plugin.family','plugin.type',
    'severity','severity_id','plugin.cvss3_base_score','vpr.score',
    'cve',
    'first_found','last_found',
    'port.port','protocol',
    'plugin.cve_all'
  )
}

# Region candidates (auto‑probe)
$RegionCandidates = @('https://cloud.tenable.com','https://cloud.tenable.eu','https://cloud.tenablegov.com')

# ============================ HELPERS ============================
function New-AuthHeaders {
  param([string]$AccessKey,[string]$SecretKey,[string]$OrganizationId)
  $h = @{ 'Accept'='application/json'; 'X-ApiKeys'="accessKey=$AccessKey; secretKey=$SecretKey;" }
  if ($OrganizationId) { $h['X-Organization'] = $OrganizationId }
  return $h
}

function Invoke-WithRetry {
  param([Parameter(Mandatory)][scriptblock]$Script,[int]$MaxAttempts=6)
  $delay=1
  for($i=1;$i -le $MaxAttempts;$i++){
    try { return & $Script }
    catch {
      $status=$null; try { $status=$_.Exception.Response.StatusCode.value__ } catch {}
      if ($status -in 429,500,502,503,504) {
        Start-Sleep -Seconds $delay; $delay=[Math]::Min($delay*2,30)
        if ($i -eq $MaxAttempts) { throw }
      } else { throw }
    }
  }
}

# ---- Preflight (auth/region/org) ----
function Test-TenableAuth {
  param([string]$BaseUrl,[string]$AccessKey,[string]$SecretKey,[string]$OrganizationId)
  $headers = New-AuthHeaders -AccessKey $AccessKey -SecretKey $SecretKey -OrganizationId $OrganizationId
  $endpoints = @('/session','/users')
  foreach ($ep in $endpoints) {
    try {
      $u = ($BaseUrl.TrimEnd('/')) + $ep
      $r = Invoke-RestMethod -Method GET -Uri $u -Headers $headers -ErrorAction Stop
      return @{ Success=$true; BaseUrl=$BaseUrl; Org=$OrganizationId; Message="Auth OK via $ep" }
    }
    catch {
      $errJson=$null
      try { $raw=$_.ErrorDetails.Message; if ($raw) { $errJson = $raw | ConvertFrom-Json -ErrorAction Stop } } catch {}
      $msg = if ($errJson) { $errJson.error ?? $errJson.message } else { $_.Exception.Message }
      if ($msg -match 'does not appear to be related to any active containers') { return @{ Success=$false; Code='WrongProductOrOrg'; Message=$msg; BaseUrl=$BaseUrl; Org=$OrganizationId } }
      if ($msg -match 'Unauthorized|Forbidden|Invalid credentials|401|403')      { return @{ Success=$false; Code='AuthFail';          Message=$msg; BaseUrl=$BaseUrl; Org=$OrganizationId } }
      # try next endpoint
    }
  }
  return @{ Success=$false; Code='Unknown'; Message='Endpoints not accessible.'; BaseUrl=$BaseUrl; Org=$OrganizationId }
}

function Select-TenableEndpoint {
  param([string[]]$BaseUrls,[string]$AccessKey,[string]$SecretKey,[string]$OrganizationId)
  $orgCandidates=@($null); if ($OrganizationId) { $orgCandidates=@($null,$OrganizationId) }
  foreach($b in $BaseUrls){ foreach($org in $orgCandidates){
    $probe = Test-TenableAuth -BaseUrl $b -AccessKey $AccessKey -SecretKey $SecretKey -OrganizationId $org
    $orgDisp = if ($org) { $org } else { '<none>' }
    Write-Host ("[Probe] {0} (X-Organization={1}) => Success={2}; {3}" -f $b,$orgDisp,$probe.Success,$probe.Message)
    if ($probe.Success) { return $probe }
  }}
  throw "Tenable preflight failed. Likely causes:\n• Keys generated for the wrong product (Container Security vs Vulnerability Management).\n• Wrong region (US vs EU vs Gov).\n• MSSP tenant missing X-Organization header or wrong org UUID.\nActions:\n1) Regenerate API keys in Vulnerability Management (My Account → API Keys).\n2) Verify tenant region (.com/.eu/.gov).\n3) If MSSP, set `$Config.OrganizationId` to your org UUID and re-run."
}

# ---- Export helpers ----
function Start-TenableVulnExport { param($Config)
  $headers = New-AuthHeaders -AccessKey $Config.AccessKey -SecretKey $Config.SecretKey -OrganizationId $Config.OrganizationId
  $uri = "$($Config.BaseUrl)/vulns/export"
  $bodyJson = ($Config.ExportBody | ConvertTo-Json -Depth 10)
  $resp = Invoke-WithRetry -Script { Invoke-RestMethod -Method POST -Uri $uri -Headers $headers -ContentType 'application/json' -Body $bodyJson }
  if (-not $resp.export_uuid) { throw 'No export_uuid returned.' }
  return $resp.export_uuid
}

function Get-TenableExportStatus { param($Config,[string]$ExportUuid)
  $headers = New-AuthHeaders -AccessKey $Config.AccessKey -SecretKey $Config.SecretKey -OrganizationId $Config.OrganizationId
  $uri = "$($Config.BaseUrl)/vulns/export/$ExportUuid/status"
  Invoke-WithRetry -Script { Invoke-RestMethod -Method GET -Uri $uri -Headers $headers }
}

function Get-TenableChunk { param($Config,[string]$ExportUuid,[int]$ChunkId,[string]$OutFile)
  $headers = New-AuthHeaders -AccessKey $Config.AccessKey -SecretKey $Config.SecretKey -OrganizationId $Config.OrganizationId
  $uri = "$($Config.BaseUrl)/vulns/export/$ExportUuid/chunks/$ChunkId"
  Invoke-WithRetry -Script { Invoke-RestMethod -Method GET -Uri $uri -Headers $headers -OutFile $OutFile } | Out-Null
}

# =================== CSV/Parsing (robust, force CVE) ===================
function Format-CsvField { param([object]$Value)
  if ($null -eq $Value) { return '' }
  $s = [string]$Value
  if ($s.Contains('"')) { $s = $s.Replace('"','""') }
  if ($s.Contains(',') -or $s.Contains("`n") -or $s.Contains("`r") -or $s.StartsWith(' ') -or $s.EndsWith(' ')) { return '"' + $s + '"' }
  return $s
}
function Write-CsvHeader { param([System.IO.StreamWriter]$W,[string[]]$Cols) ; $W.WriteLine(($Cols | ForEach-Object { Format-CsvField $_ }) -join ',') }
function Write-CsvRow    { param([System.IO.StreamWriter]$W,[hashtable]$Row,[string[]]$Cols) ; $W.WriteLine(($Cols | ForEach-Object { Format-CsvField $Row[$_] }) -join ',') }

function Get-NestedRaw { param($Obj,[string]$Path)
  if (-not $Obj) { return $null }
  $curr=$Obj
  foreach($seg in $Path -split '\.'){
    if ($null -eq $curr) { return $null }
    $prop = $curr.PSObject.Properties[$seg]
    if (-not $prop) { return $null }
    $curr=$prop.Value
  }
  return $curr
}
function Get-EpochUtc { param($Epoch)
  if ($null -eq $Epoch -or $Epoch -eq '') { return $null }
  if ($Epoch -is [int] -or ($Epoch -is [string] -and $Epoch -match '^\d{9,}$')) {
    try { return [DateTimeOffset]::FromUnixTimeSeconds([int64]$Epoch).UtcDateTime } catch { return $Epoch }
  }
  return $Epoch
}

# Extract CVEs from plugin.cve, plugin.xrefs, and text scraping
$script:CveRegex = [regex]'CVE-\d{4}-\d{4,7}'
function Get-AllCves { param($Obj)
  $set  = New-Object System.Collections.Generic.LinkedList[string]  # preserve order
  $seen = New-Object System.Collections.Generic.HashSet[string]

  # 1) plugin.cve
  $fromPlugin = Get-NestedRaw $Obj 'plugin.cve'
  if ($fromPlugin -ne $null) {
    if ($fromPlugin -is [System.Collections.IEnumerable] -and -not ($fromPlugin -is [string])) {
      foreach($c in $fromPlugin){ if ($c) { $cv=[string]$c; if ($cv -match '^CVE-') { if ($seen.Add($cv)) { $set.AddLast($cv) | Out-Null } } } }
    } else { $cv=[string]$fromPlugin; if ($cv -match '^CVE-') { if ($seen.Add($cv)) { $set.AddLast($cv) | Out-Null } } }
  }

  # 2) plugin.xrefs
  $xrefs = Get-NestedRaw $Obj 'plugin.xrefs'
  if ($xrefs -is [System.Collections.IEnumerable] -and -not ($xrefs -is [string])) {
    foreach($x in $xrefs){ if ($null -ne $x) { $cv=[string]$x; if ($cv -match '^CVE-\d{4}-\d{4,7}$') { if ($seen.Add($cv)) { $set.AddLast($cv) | Out-Null } } } }
  }

  # 3) scrape name/description
  foreach($field in @('plugin.name','plugin.description')){
    $text = Get-NestedRaw $Obj $field
    if ($text) {
      foreach($m in $script:CveRegex.Matches([string]$text)) { $cv=$m.Value; if ($seen.Add($cv)) { $set.AddLast($cv) | Out-Null } }
    }
  }

  $out=@(); foreach($cv in $set){ $out += $cv }; return ,$out
}

function Emit-VulnRows { param([pscustomobject]$obj,[System.IO.StreamWriter]$sw,[string[]]$Columns,[bool]$RequireCve,[string]$NoCveFormat)
  $base = [ordered]@{
    'plugin.id'               = Get-NestedRaw $obj 'plugin.id'
    'plugin.name'             = Get-NestedRaw $obj 'plugin.name'
    'plugin.family'           = Get-NestedRaw $obj 'plugin.family'
    'plugin.type'             = Get-NestedRaw $obj 'plugin.type'
    'plugin.cvss3_base_score' = Get-NestedRaw $obj 'plugin.cvss3_base_score'
    'severity'                = Get-NestedRaw $obj 'severity'
    'severity_id'             = Get-NestedRaw $obj 'severity_id'
    'vpr.score'               = Get-NestedRaw $obj 'vpr.score'
    'asset.uuid'              = Get-NestedRaw $obj 'asset.uuid'
    'asset.hostname'          = Get-NestedRaw $obj 'asset.hostname'
    'first_found'             = Get-EpochUtc (Get-NestedRaw $obj 'first_found')
    'last_found'              = Get-EpochUtc (Get-NestedRaw $obj 'last_found')
    'port.port'               = Get-NestedRaw $obj 'port.port'
    'protocol'                = Get-NestedRaw $obj 'port.protocol'
    'plugin.cve_all'          = $null
  }
  if ($null -eq $base['port.port']) { $base['port.port'] = Get-NestedRaw $obj 'port' }
  if ($null -eq $base['protocol'])  { $base['protocol']  = Get-NestedRaw $obj 'protocol' }

  $allCves = Get-AllCves $obj
  $base['plugin.cve_all'] = if ($allCves.Count -gt 0) { ($allCves -join ';') } else { $null }

  if ($RequireCve -and ($allCves.Count -eq 0)) {
    $pluid = if ($base['plugin.id']) { $base['plugin.id'] } else { 'UNKNOWN' }
    $allCves = @([string]::Format($NoCveFormat, $pluid))
  }

  $rows=0
  foreach($cve in $allCves){
    $row = @{
      'asset.uuid'              = $base['asset.uuid']
      'asset.hostname'          = $base['asset.hostname']
      'plugin.id'               = $base['plugin.id']
      'plugin.name'             = $base['plugin.name']
      'plugin.family'           = $base['plugin.family']
      'plugin.type'             = $base['plugin.type']
      'severity'                = $base['severity']
      'severity_id'             = $base['severity_id']
      'plugin.cvss3_base_score' = $base['plugin.cvss3_base_score']
      'vpr.score'               = $base['vpr.score']
      'cve'                     = $cve
      'first_found'             = $base['first_found']
      'last_found'              = $base['last_found']
      'port.port'               = $base['port.port']
      'protocol'                = $base['protocol']
      'plugin.cve_all'          = $base['plugin.cve_all']
    }
    Write-CsvRow -W $sw -Row $row -Cols $Columns
    $rows++
  }
  return $rows
}

function Convert-TenableJson-AnyShape { param([string]$PathIn,[string]$PathOut,[string[]]$Columns,[bool]$RequireCve,[string]$NoCveFormat)
  if (-not (Test-Path -LiteralPath $PathIn)) { throw "File not found: $PathIn" }
  Write-Host "Reading JSON from: $PathIn"
  Write-Host "Writing CSV to   : $PathOut"

  # Peek first non‑whitespace char
  $fs = [System.IO.File]::OpenRead($PathIn)
  try {
    $br = New-Object System.IO.StreamReader($fs, [Text.UTF8Encoding]::new($true), $true, 65536, $true)
    $firstNonWs = $null
    while ($br.Peek() -ne -1) { $ch=[char]$br.Read(); if (-not [char]::IsWhiteSpace($ch)) { $firstNonWs=$ch; break } }
  } finally { $fs.Close() }

  $sw = [System.IO.StreamWriter]::new($PathOut, $false, [Text.UTF8Encoding]::new($true))
  Write-CsvHeader -W $sw -Cols $Columns
  $rowsOut = 0

  if ($firstNonWs -eq '[') {
    # Big JSON array
    $json = Get-Content -Path $PathIn -Raw -Encoding UTF8
    $arr  = $json | ConvertFrom-Json -Depth 64
    foreach ($obj in $arr) { $rowsOut += Emit-VulnRows -obj $obj -sw $sw -Columns $Columns -RequireCve:$RequireCve -NoCveFormat $NoCveFormat }
  } else {
    # NDJSON or concatenated objects
    $sr = [System.IO.StreamReader]::new($PathIn, [Text.UTF8Encoding]::new($true))
    try {
      $buf      = New-Object System.Text.StringBuilder
      $depth    = 0
      $inString = $false
      $escape   = $false
      $seenObjStart = $false

      while ($true) {
        $i = $sr.Read(); if ($i -eq -1) { break }
        $c = [char]$i; [void]$buf.Append($c)
        if ($inString) {
          if ($escape) { $escape=$false }
          elseif ($c -eq '\\') { $escape=$true }
          elseif ($c -eq '"') { $inString=$false }
          continue
        }
        if ($c -eq '"') { $inString=$true; continue }
        if ($c -eq '{') { $depth++; $seenObjStart=$true; continue }
        if ($c -eq '}') { $depth-- }
        if ($seenObjStart -and $depth -eq 0) {
          $text = $buf.ToString(); $buf.Clear() | Out-Null; $seenObjStart=$false
          try { $obj = $text | ConvertFrom-Json -Depth 64; if ($obj) { $rowsOut += Emit-VulnRows -obj $obj -sw $sw -Columns $Columns -RequireCve:$RequireCve -NoCveFormat $NoCveFormat } } catch {}
        }
      }
      if ($buf.Length -gt 0) {
        try { $obj = $buf.ToString() | ConvertFrom-Json -Depth 64; if ($obj) { $rowsOut += Emit-VulnRows -obj $obj -sw $sw -Columns $Columns -RequireCve:$RequireCve -NoCveFormat $NoCveFormat } } catch {}
      }
    } finally { $sr.Close() }
  }

  $sw.Close()
  Write-Host ("CSV rows emitted : {0:n0}" -f $rowsOut)
  Write-Host "Output CSV: $PathOut"
}

# ============================ MAIN ============================
# Prepare output folder and paths
New-Item -ItemType Directory -Path $Config.OutFolder -Force | Out-Null
$NdjsonPath = Join-Path $Config.OutFolder 'combined.ndjson'
$CsvPath    = Join-Path $Config.OutFolder 'vulns_cve_exploded.csv'

"Starting export with filters:`n$(($Config.ExportBody | ConvertTo-Json -Depth 10))" | Write-Host

# Preflight: auto‑pick region and (optional) org header
$choice = Select-TenableEndpoint -BaseUrls $RegionCandidates -AccessKey $Config.AccessKey -SecretKey $Config.SecretKey -OrganizationId $Config.OrganizationId
$Config.BaseUrl        = $choice.BaseUrl
$Config.OrganizationId = $choice.Org  # may be $null
Write-Host ("Using BaseUrl: {0}  (X-Organization: {1})" -f $Config.BaseUrl, ($Config.OrganizationId ?? '<none>'))

# Start export
$uuid = Start-TenableVulnExport -Config $Config
Write-Host "Export UUID: $uuid"

# Poll status until finished or timeout
$deadline = (Get-Date).AddMinutes($Config.MaxPollMinutes)
$availableChunks = @()
do {
  Start-Sleep -Seconds $Config.ChunkPollSeconds
  $status = Get-TenableExportStatus -Config $Config -ExportUuid $uuid
  $state  = $status.status
  $chunks = $status.chunks_available
  Write-Host "Status: $state | Chunks available: $($chunks -join ', ')"
  if ($chunks) { $availableChunks = $chunks }
  if ((Get-Date) -gt $deadline) { throw 'Timed out waiting for export to complete.' }
} while ($state -ne 'FINISHED' -and $state -ne 'ERROR')
if ($state -eq 'ERROR') { throw 'Export reported ERROR.' }

# Download chunks
$chunkFiles = @()
foreach($cid in $availableChunks) {
  $f = Join-Path $Config.OutFolder ("chunk_{0:D4}.ndjson" -f [int]$cid)
  Write-Host "Downloading chunk $cid => $f"
  Get-TenableChunk -Config $Config -ExportUuid $uuid -ChunkId $cid -OutFile $f
  $chunkFiles += $f
}

# Merge NDJSON chunks
Write-Host "Merging $(($chunkFiles | Measure-Object).Count) chunks into $NdjsonPath"
$swMerge = [System.IO.StreamWriter]::new($NdjsonPath, $false, [System.Text.UTF8Encoding]::new($true))
try {
  foreach($cf in ($chunkFiles | Sort-Object)) {
    Get-Content -Path $cf -Encoding UTF8 | ForEach-Object { $swMerge.WriteLine($_) }
  }
} finally { $swMerge.Close() }

# Convert merged NDJSON to CVE‑exploded CSV using robust parser (forces CVE)
Write-Host "Converting NDJSON => CVE‑exploded CSV ($CsvPath)"
Convert-TenableJson-AnyShape -PathIn $NdjsonPath -PathOut $CsvPath -Columns $Config.Columns -RequireCve:$Config.RequireCve -NoCveFormat $Config.NoCveFormat

Write-Host "`nDone!"; Write-Host " - NDJSON: $NdjsonPath"; Write-Host " - CVE‑Exploded CSV: $CsvPath"
